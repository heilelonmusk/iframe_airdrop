{"version":3,"file":"server.bundle.js","mappings":"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","sources":["webpack://iframe_airdrop/./api/server.js","webpack://iframe_airdrop/./config/redis.js","webpack://iframe_airdrop/./modules/intent/intentRecognizer.js","webpack://iframe_airdrop/./modules/logging/logger.js","webpack://iframe_airdrop/./modules/nlp/nlpModel.js","webpack://iframe_airdrop/./modules/nlp/transformer.js","webpack://iframe_airdrop/external commonjs \"connect-timeout\"","webpack://iframe_airdrop/external commonjs \"cors\"","webpack://iframe_airdrop/external commonjs \"dotenv\"","webpack://iframe_airdrop/external commonjs \"express\"","webpack://iframe_airdrop/external commonjs \"express-rate-limit\"","webpack://iframe_airdrop/external node-commonjs \"fs\"","webpack://iframe_airdrop/external commonjs \"ioredis\"","webpack://iframe_airdrop/external commonjs \"mongoose\"","webpack://iframe_airdrop/external commonjs \"openai\"","webpack://iframe_airdrop/external commonjs \"path\"","webpack://iframe_airdrop/external commonjs \"serverless-http\"","webpack://iframe_airdrop/external commonjs \"winston\"","webpack://iframe_airdrop/webpack/bootstrap","webpack://iframe_airdrop/webpack/runtime/node module decorator","webpack://iframe_airdrop/webpack/before-startup","webpack://iframe_airdrop/webpack/startup","webpack://iframe_airdrop/webpack/after-startup"],"sourcesContent":["require(\"dotenv\").config();\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst serverless = require(\"serverless-http\");\nconst rateLimit = require(\"express-rate-limit\");\nconst cors = require(\"cors\");\nconst timeout = require(\"connect-timeout\");\nconst { loadNLPModel, saveNLPModel, NLPModel } = require(\"../modules/nlp/nlpModel\");\n//const winston = require(\"winston\");\nconst redis = require(\"../config/redis\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst port = process.env.PORT || 8889;\nconst { logger, logConversation, getFrequentQuestions } = require(\"..modules/logging/logger\");\n//logger.error(\"This is an error message\");\n\n// Import dei moduli\nconst { getIntent } = require(\"../modules/intent/intentRecognizer\");\nconst { generateResponse } = require(\"../modules/nlp/transformer\");\n//const { logConversation } = require(\"../modules/logging/logger\");\n\n// Inizializza il manager NLP\n//const manager = new NlpManager({ languages: [\"en\"], autoSave: false, autoLoad: false });\n\n// Configurazione del logger con Winston\nconst logDir = process.env.NODE_ENV === \"development\" ? \"/tmp/logs\" : path.join(__dirname, \"../logs\");\nif (!fs.existsSync(logDir)) {\n  fs.mkdirSync(logDir, { recursive: true });\n}\n//const logger = winston.createLogger({\n//  level: \"info\",\n//  format: winston.format.combine(\n//    winston.format.timestamp(),\n//    winston.format.printf(({ timestamp, level, message }) => `[${timestamp}] ${level.toUpperCase()}: ${message}`)\n//  ),\n//  transports: [\n//    new winston.transports.Console(),\n//    new winston.transports.File({\n//      filename: path.join(logDir, \"server.log\"),\n//      maxsize: 1024 * 1024 * 5, // Max 5MB\n//      maxFiles: 3,\n//      tailable: true\n//    }),\n//  ],\n// });\n\n// Crea l'app Express e il router\nconst app = express();\nconst router = express.Router();\n\n// Middleware\napp.set(\"trust proxy\", true);\napp.use(cors({ origin: \"https://helon.space\", credentials: true }));\napp.use(express.json());\napp.use(timeout(\"10s\"));\n\n// Rate Limiting\napp.use(\n  rateLimit({\n    windowMs: 60 * 1000,\n    max: 10,\n    message: \"Too many requests. Please try again later.\",\n    keyGenerator: (req) => req.ip,\n  })\n);\n\n// ✅ Connessione a Redis\n//console.log(\"🔹 REDIS_HOST:\", process.env.REDIS_HOST);\n//console.log(\"🔹 REDIS_PORT:\", process.env.REDIS_PORT);\n//console.log(\"🔹 REDIS_PASSWORD:\", process.env.REDIS_PASSWORD ? \"********\" : \"Not Set\");\n//const redis = new Redis({\n//  host: process.env.REDIS_HOST,\n//  port: process.env.REDIS_PORT,\n//  password: process.env.REDIS_PASSWORD,\n//  tls: {},\n//  retryStrategy: (times) => {\n//    if (times > 10) {\n//      logger.error(\"❌ Too many Redis reconnection attempts. Stopping...\");\n//      return null;\n//    }\n//   return Math.min(times * 1000, 30000);\n//  }\n// });\n\n//redis.on(\"connect\", () => logger.info(\"✅ Connected to Redis successfully!\"));\n//redis.on(\"error\", (err) => logger.error(`❌ Redis connection error: ${err.message}`));\n//redis.on(\"end\", () => {\n//  logger.warn(\"⚠️ Redis connection closed. Reconnecting...\");\n//  setTimeout(() => redis.connect(), 5000);\n//});\n\n// Funzione per connettersi a MongoDB con gestione forzata se rimane in stato \"connecting\"\nconst connectMongoDB = async () => {\n  // Se già connesso (stato 1), restituisci la connessione attiva\n  if (mongoose.connection.readyState === 1) {\n    logger.info(\"🔄 MongoDB already connected, reusing existing connection.\");\n    return mongoose.connection;\n  }\n  \n  // Se rimane in \"connecting\" (stato 2), forziamo la disconnessione e attendiamo che lo stato diventi 0 (disconnesso)\nif (mongoose.connection.readyState === 2) {\n  logger.warn(\"Mongoose connection is stuck in 'connecting' state. Forcing disconnect...\");\n  try {\n    await mongoose.disconnect();\n    // Attende finché lo stato non diventa 0, con un timeout massimo di 5000ms\n    await new Promise((resolve, reject) => {\n      const start = Date.now();\n      const checkState = () => {\n        if (mongoose.connection.readyState === 0) {\n          resolve();\n        } else if (Date.now() - start > 5000) {\n          reject(new Error(\"Timeout waiting for mongoose to disconnect.\"));\n        } else {\n          setTimeout(checkState, 500); // Ritardo aumentato a 500ms\n        }\n      };\n      checkState();\n    });\n    logger.info(\"Forced disconnect successful. ReadyState is now: \" + mongoose.connection.readyState);\n  } catch (err) {\n    logger.error(\"Error during forced disconnect: \" + err.message);\n  }\n}\n  \n  // Ora tenta di connettersi\ntry {\n  await mongoose.connect(process.env.MONGO_URI, {\n    // Le opzioni deprecate possono essere omesse con il driver 4.x\n  });\n  logger.info(\"📚 Connected to MongoDB\");\n\n  // Aggiungi i listener di connessione\n  mongoose.connection.on(\"error\", (err) => logger.error(\"MongoDB error:\", err));\n  mongoose.connection.on(\"disconnected\", () => logger.warn(\"MongoDB disconnected.\"));\n  mongoose.connection.on(\"reconnected\", () => logger.info(\"MongoDB reconnected!\"));\n} catch (err) {\n  logger.error(`❌ MongoDB connection error: ${err.message}`);\n}\n\n// Attende un po' per permettere l'aggiornamento dello stato\nawait new Promise((resolve) => setTimeout(resolve, 1000));\nlogger.info(\"Final mongoose.connection.readyState: \" + mongoose.connection.readyState);\nreturn mongoose.connection;\n};\n\n// Endpoint /health aggiornato con log dettagliati (il resto rimane invariato)\nrouter.get(\"/health\", async (req, res) => {\n  try {\n    logger.info(\"🔹 Health check started...\");\n\n    // Log dello stato iniziale della connessione\n    let currentState = mongoose.connection.readyState;\n    logger.info(`Current mongoose.connection.readyState: ${currentState}`);\n    \n    // Se non è 1, tentiamo la riconnessione\n    if (currentState !== 1) {\n      logger.warn(`⚠️ MongoDB not connected (state ${currentState}), attempting to reconnect...`);\n      await connectMongoDB();\n      currentState = mongoose.connection.readyState;\n      logger.info(`After reconnect attempt, mongoose.connection.readyState: ${currentState}`);\n    }\n\n    let mongoStatus = \"Disconnected\";\n    try {\n      if (mongoose.connection.readyState === 1 && mongoose.connection.db) {\n        logger.info(\"Performing MongoDB ping command...\");\n        const pingResult = await mongoose.connection.db.command({ ping: 1 });\n        logger.info(\"MongoDB ping result: \" + JSON.stringify(pingResult));\n        if (pingResult && pingResult.ok === 1) {\n          mongoStatus = \"Connected\";\n        } else {\n          logger.warn(\"MongoDB ping did not return an ok result\");\n        }\n      } else {\n        logger.warn(\"mongoose.connection.readyState is not 1 or mongoose.connection.db is not available\");\n      }\n    } catch (pingError) {\n      logger.error(\"MongoDB ping error: \" + pingError.message);\n      mongoStatus = \"Disconnected\";\n    }\n    logger.info(`🔹 MongoDB Status: ${mongoStatus}`);\n\n    let redisStatus = \"Disconnected\";\n    try {\n      if (redis.status === \"ready\") {\n        logger.info(\"Performing Redis ping...\");\n        const redisPing = await redis.ping();\n        logger.info(\"Redis ping result: \" + redisPing);\n        redisStatus = redisPing === \"PONG\" ? \"Connected\" : \"Disconnected\";\n      } else {\n        logger.warn(`Redis status not ready: ${redis.status}`);\n      }\n    } catch (redisError) {\n      logger.error(\"Redis ping error: \" + redisError.message);\n      redisStatus = \"Disconnected\";\n    }\n\n    res.json({ status: \"✅ Healthy\", mongo: mongoStatus, redis: redisStatus });\n  } catch (error) {\n    logger.error(`❌ Health check failed: ${error.message}`);\n    res.status(500).json({ error: \"Service is unhealthy\", details: error.message });\n  }\n});\n\napp.use(\"/.netlify/functions/server\", router);\n\n// Schema & Model per Knowledge Base\nconst questionSchema = new mongoose.Schema({\n  question: { type: String, required: true, unique: true },\n  answer: { type: mongoose.Schema.Types.Mixed, required: true },\n  source: { type: String, default: \"Ultron AI\" },\n  createdAt: { type: Date, default: Date.now },\n});\nconst Question = mongoose.models.Question || mongoose.model(\"Question\", questionSchema);\n\n// Schema per NLP Model\n//const NLPModelSchema = new mongoose.Schema({\n//  modelData: { type: Object, required: true },\n//});\n//const NLPModel = mongoose.models.NLPModel || mongoose.model(\"NLPModel\", NLPModelSchema);\n\n// Inizializza il modello NLP (aggiornato per attendere la connessione a MongoDB)\n(async () => {\n  try {\n    // Attende esplicitamente che la connessione sia attiva\n    await connectMongoDB();\n    \n    // Ora è sicuro eseguire le operazioni sul database\n    const savedModel = await loadNLPModel();\n    if (savedModel) {\n      manager.import(savedModel);\n      logger.info(\"🧠 NLP Model Loaded from DB\");\n    } else {\n      await trainAndSaveNLP();\n    }\n  } catch (error) {\n    logger.error(\"❌ Error initializing NLP model:\", error);\n  }\n})();\n\n// Funzione per allenare e salvare il modello NLP\nasync function trainAndSaveNLP() {\n  manager.addDocument(\"en\", \"hello\", \"greeting\");\n  await manager.train();\n  await saveNLPModel(manager.export());\n  logger.info(\"✅ New NLP Model trained and saved!\");\n}\n\n// Endpoint per gestire le domande degli utenti\nrouter.post(\"/logQuestion\", async (req, res) => {\n  try {\n    const { question } = req.body;\n    if (!question) return res.status(400).json({ error: \"Question is required\" });\n\n    const storedAnswer = await Question.findOne({ question });\n    if (storedAnswer) return res.json({ answer: storedAnswer.answer, source: storedAnswer.source });\n\n    const intentResult = await manager.process(\"en\", question);\n    if (!intentResult.answer) {\n      return res.status(404).json({ error: \"No answer available for this question.\" });\n    }\n\n    const finalAnswer = intentResult.answer;\n    await new Question({ question, answer: finalAnswer, source: \"Ultron AI\" }).save();\n    res.json({ answer: finalAnswer, source: \"Ultron AI\" });\n  } catch (error) {\n    logger.error(`❌ Error processing question: ${error.message}`);\n    res.status(500).json({ error: \"Server error\", details: error.message });\n  }\n});\n\n// ✅ Nuovi endpoint: /fetch, /store, /download\nrouter.get(\"/fetch\", async (req, res) => {\n  const { source, file, query } = req.query;\n  if (source === \"github\") {\n    return res.json({ data: `Simulated content from GitHub for ${file}` });\n  } else if (source === \"mongodb\") {\n    return res.json({ data: { key: query, value: \"Simulated MongoDB data\" } });\n  } else {\n    return res.status(400).json({ error: \"Unrecognized source\" });\n  }\n});\n\n// Avvio del server (solo se eseguito come modulo principale e non in ambiente serverless)\nif (require.main === module && !process.env.NETLIFY) {\n  app.listen(port, () => logger.info(`Server running on port ${port}`));\n}\n\nmodule.exports = { app, handler: serverless(app), redis };","require(\"dotenv\").config();\nconst Redis = require(\"ioredis\");\nconst winston = require(\"winston\");\n\nconst logger = winston.createLogger({\n  level: \"info\",\n  format: winston.format.combine(\n    winston.format.timestamp({ format: \"HH:mm:ss\" }),\n    winston.format.printf(({ timestamp, level, message }) => `[${timestamp}] ${level.toUpperCase()}: ${message}`)\n  ),\n  transports: [new winston.transports.Console()],\n});\n\nconst redis = new Redis({\n  host: process.env.REDIS_HOST,\n  port: Number(process.env.REDIS_PORT),\n  password: process.env.REDIS_PASSWORD,\n  tls: { rejectUnauthorized: false },\n  enableOfflineQueue: false,\n  connectTimeout: 5000,\n  retryStrategy: (times) => Math.min(times * 100, 2000),\n  family: 4,\n});\n\nredis.on(\"connect\", () => logger.info(\"✅ Redis connesso con successo.\"));\nredis.on(\"error\", (err) => logger.error(\"❌ Errore connessione Redis:\", err.message));\n\nmodule.exports = redis;","require('dotenv').config();\nconst { loadNLPModel, saveNLPModel, NLPModel } = require(\"../nlp/nlpModel\");\n\nconst manager = new NlpManager({ languages: ['en'], forceNER: true, autoSave: false });\n\n// ✅ **Predefined Intents & Responses**\nconst predefinedIntents = {\n  \"greeting\": \"Hello! How can I assist you today?\",\n  \"farewell\": \"Goodbye! Have a great day!\",\n  \"channels\": \"Here are the official channels:\\n- Twitter: https://x.com/heilelon_\\n- Instagram: https://instagram.com/heil.elonmusk\\n- Telegram: https://t.me/heil_elon\",\n  \"help\": \"I can help you with information about Helon, its ecosystem, and tokens. Just ask!\"\n};\n\n// ✅ **Train NLP Model**\nasync function trainNLP() {\n  console.log(\"🧠 Training NLP Model...\");\n\n  manager.addDocument('en', 'hello', 'greeting');\n  manager.addDocument('en', 'hi there', 'greeting');\n  manager.addDocument('en', 'goodbye', 'farewell');\n  manager.addDocument('en', 'bye', 'farewell');\n  manager.addDocument('en', 'where can I find official channels?', 'channels');\n  manager.addDocument('en', 'how can I contact Helon?', 'channels');\n  manager.addDocument('en', 'help', 'help');\n  manager.addDocument('en', 'what can you do?', 'help');\n\n  await manager.train();\n  console.log(\"✅ NLP Model Trained Successfully!\");\n\n  const exportedModel = manager.export();\n  await saveNLPModel(exportedModel);\n  console.log(\"✅ NLP Model saved in MongoDB\");\n}\n\n// ✅ **Intent Recognition Function**\nasync function getIntent(question) {\n  console.log(`🔍 Analyzing intent for: \"${question}\"`);\n\n  const result = await manager.process('en', question);\n  \n  if (result.intent && result.score > 0.7) {\n    console.log(`✅ Intent Detected: \"${result.intent}\" (Score: ${result.score})`);\n    \n    if (predefinedIntents[result.intent]) {\n      return { intent: result.intent, answer: predefinedIntents[result.intent], score: result.score };\n    }\n    \n    return { intent: result.intent, answer: null, score: result.score };\n  }\n\n  console.warn(\"⚠ Unrecognized Intent - Fallback Triggered.\");\n  return { intent: \"unknown\", answer: \"I'm not sure how to answer that yet. Try rephrasing?\", score: 0 };\n}\n\n// ✅ **Train Model on Startup**\nasync function initializeNLP() {\n  const savedModel = await loadNLPModel();\n  if (savedModel) {\n    manager.import(savedModel);\n    console.log(\"🧠 NLP Model Loaded from DB\");\n  } else {\n    console.log(\"🚀 Training new NLP Model...\");\n    await trainNLP();\n  }\n}\n\nmodule.exports = { getIntent, initializeNLP, trainModel };","require('dotenv').config();\nconst mongoose = require('mongoose');\n\nconst LOG_RETENTION_DAYS = 30; // Auto-delete logs older than this\nconst MONGO_URI = process.env.MONGO_URI;\n\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: \"info\",\n  format: winston.format.combine(\n    winston.format.timestamp({ format: \"HH:mm:ss\" }),\n    winston.format.printf(({ timestamp, level, message }) => `[${timestamp}] ${level.toUpperCase()}: ${message}`)\n  ),\n  transports: [\n    new winston.transports.Console(),\n    // Aggiungi altri transport se necessario (es. File)\n  ]\n});\n\nif (!MONGO_URI) {\n  console.error(\"❌ ERROR: MONGO_URI is missing! Logging is disabled.\");\n  process.exit(1);\n}\n\n// Connessione a MongoDB per il logging\nmongoose.connect(MONGO_URI, { })\n  .then(() => console.log(\"📜 Connected to MongoDB for logging\"))\n  .catch(err => {\n    console.error(\"❌ MongoDB connection error:\", err);\n    process.exit(1);\n  });\n\n// Schema per il logging delle conversazioni\nconst logSchema = new mongoose.Schema({\n  userId: { type: String, default: \"anonymous\" },\n  question: { type: String, required: true },\n  answer: { type: String, required: true }, // Salvato sempre come stringa (JSON)\n  detectedIntent: { type: String },\n  confidence: { type: Number },\n  timestamp: { type: Date, default: Date.now }\n});\n\n// Creazione del modello ConversationLog\nconst ConversationLog = mongoose.models.ConversationLog || mongoose.model('ConversationLog', logSchema);\n\n// Funzione per loggare una conversazione\nasync function logConversation({ userId, question, answer, detectedIntent, confidence }) {\n  try {\n    const logEntry = new ConversationLog({\n      userId,\n      question,\n      answer: typeof answer === \"string\" ? answer : JSON.stringify(answer),\n      detectedIntent,\n      confidence\n    });\n\n    await logEntry.save();\n    console.log(\"📝 Conversation logged successfully.\");\n  } catch (error) {\n    console.error(\"❌ Error logging conversation:\", error);\n  }\n}\n\n// Funzione per recuperare le domande più frequenti\nasync function getFrequentQuestions(limit = 5) {\n  try {\n    const results = await ConversationLog.aggregate([\n      { $group: { _id: \"$question\", count: { $sum: 1 } } },\n      { $sort: { count: -1 } },\n      { $limit: limit }\n    ]);\n\n    if (!Array.isArray(results)) {\n      console.error(\"❌ Expected aggregation results to be an array, got:\", results);\n      return [];\n    }\n    \n    return results.map(q => ({ question: q._id, count: q.count }));\n  } catch (error) {\n    console.error(\"❌ Error retrieving frequent questions:\", error);\n    return [];\n  }\n}\n\n// Funzione per eliminare automaticamente i log vecchi (Retention Policy)\nasync function cleanupOldLogs() {\n  try {\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() - LOG_RETENTION_DAYS);\n    const result = await ConversationLog.deleteMany({ timestamp: { $lt: cutoff } });\n    console.log(`🗑 Deleted ${result.deletedCount} old log entries.`);\n  } catch (error) {\n    console.error(\"❌ Error deleting old logs:\", error);\n  }\n}\n\n// Pianifica la pulizia dei log ogni 24 ore\nconst intervalId = setInterval(cleanupOldLogs, 24 * 60 * 60 * 1000);\nintervalId.unref();\n\nmodule.exports = { \n  logger, \n  logConversation, \n  getFrequentQuestions \n};","const mongoose = require('mongoose');\nconst { logger, logConversation, getFrequentQuestions } = require(\"../logging/logger\");\n\nconst NLPModelSchema = new mongoose.Schema({\n  modelData: { type: Object, required: true }\n});\n\nconst NLPModel = mongoose.models.NLPModel || mongoose.model('NLPModel', NLPModelSchema);\n\n// ✅ Carica il modello NLP dal database\nasync function loadNLPModel() {\n  try {\n    const savedModel = await NLPModel.findOne({});\n    if (savedModel) {\n      logger.info(\"✅ NLP Model loaded from MongoDB\");\n      return savedModel.modelData;\n    }\n    logger.warn(\"⚠️ No NLP Model found in database. Training required.\");\n    return null;\n  } catch (error) {\n    logger.error(\"❌ Error loading NLP model:\", error.message);\n    throw error;\n  }\n}\n\n// ✅ Salva il modello NLP nel database\nasync function saveNLPModel(modelData) {\n  try {\n    const result = await NLPModel.updateOne({}, { modelData }, { upsert: true });\n    logger.info(\"✅ NLP Model saved in MongoDB\");\n    return result;\n  } catch (error) {\n    logger.error(\"❌ Error saving NLP model:\", error.message);\n    throw error;\n  }\n}\n\nmodule.exports = { loadNLPModel, saveNLPModel, NLPModel };","require('dotenv').config();\nconst OpenAI = require(\"openai\");\nconst mongoose = require(\"mongoose\");\nconst { logger, logConversation, getFrequentQuestions } = require(\"../modules/logging/logger\");\n\n// ✅ Load OpenAI API key\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nconst MONGO_URI = process.env.MONGO_URI;\n\nif (!MONGO_URI) {\n  console.error(\"❌ ERROR: MONGO_URI is missing! Knowledge Base will not function.\");\n  process.exit(1);\n}\n\nmongoose.connect(MONGO_URI)\n  .then(() => console.log(\"📚 Connected to MongoDB for Knowledge Base\"))\n  .catch(err => console.error(\"❌ MongoDB connection error:\", err));\n\n// ✅ **Knowledge Base Schema**\nconst knowledgeSchema = new mongoose.Schema({\n  question: { type: String, required: true, unique: true },\n  answer: { type: String, required: true },\n  source: { type: String, default: \"Knowledge Base\" },\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst Knowledge = mongoose.models.Knowledge || mongoose.model(\"Knowledge\", knowledgeSchema);\n\n// ✅ **Check Knowledge Base Before Calling GPT**\nasync function getAnswerFromKnowledgeBase(question) {\n  try {\n    const result = await Knowledge.findOne({ question: new RegExp(`^${question}$`, 'i') });\n    if (result) {\n      console.log(`📖 Answer found in Knowledge Base for: \"${question}\"`);\n      return { answer: result.answer, source: result.source };\n    }\n    return null;\n  } catch (error) {\n    console.error(\"❌ Error querying Knowledge Base:\", error);\n    return null;\n  }\n}\n\n// ✅ **Generate AI Response Using GPT (if needed)**\nasync function generateResponse(question) {\n  try {\n    // 🔹 Step 1: First check the Knowledge Base\n    const knowledgeResponse = await getAnswerFromKnowledgeBase(question);\n    if (knowledgeResponse) return knowledgeResponse;\n\n    // 🔹 Step 2: If not found, ask GPT-3.5\n    console.log(`🤖 Querying GPT-3.5 for: \"${question}\"`);\n    const response = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",  // Using cost-effective model\n      messages: [{ role: \"user\", content: question }],\n      max_tokens: 100,  // Limits response length to reduce token usage\n      temperature: 0.7,\n    });\n\n    const answer = response.choices[0]?.message?.content?.trim();\n    if (!answer) throw new Error(\"Empty response from GPT\");\n\n    // 🔹 Step 3: Store AI-generated response in Knowledge Base\n    const newEntry = new Knowledge({ question, answer, source: \"GPT-3.5\" });\n    await newEntry.save();\n    console.log(\"✅ Saved GPT response to Knowledge Base.\");\n\n    return { answer, source: \"GPT-3.5\" };\n  } catch (error) {\n    console.error(\"❌ OpenAI API Error:\", error.response ? error.response.data : error);\n    return { answer: \"Sorry, I'm having trouble processing your request.\", source: \"Ultron AI\" };\n  }\n}\n\nmodule.exports = { generateResponse };","module.exports = require(\"connect-timeout\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"express\");","module.exports = require(\"express-rate-limit\");","module.exports = require(\"fs\");","module.exports = require(\"ioredis\");","module.exports = require(\"mongoose\");","module.exports = require(\"openai\");","module.exports = require(\"path\");","module.exports = require(\"serverless-http\");","module.exports = require(\"winston\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(__webpack_require__.s = \"./api/server.js\");\n",""],"names":[],"sourceRoot":""}